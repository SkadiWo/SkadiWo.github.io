<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>诡异的鱼塘</title>
  
  <subtitle>一 个 浅 鱼 塘</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.fishsmemory.ml/"/>
  <updated>2021-05-11T15:29:21.679Z</updated>
  <id>https://blog.fishsmemory.ml/</id>
  
  <author>
    <name>Oswin Wu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang学习手记</title>
    <link href="https://blog.fishsmemory.ml/2021/05/11/Golang/Golang-Start/"/>
    <id>https://blog.fishsmemory.ml/2021/05/11/Golang/Golang-Start/</id>
    <published>2021-05-11T15:14:41.000Z</published>
    <updated>2021-05-11T15:29:21.679Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Go项目结构"><a href="#Go项目结构" class="headerlink" title="Go项目结构"></a>Go项目结构</h2><ul><li><p>go.mod</p></li><li><p>go.sum</p></li><li><p>*.go</p></li></ul><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><p>是相关Go包的集合，是源代码交换和版本控制的单元</p><p>其提供了<code>module</code>, <code>require</code>、<code>replace</code>和<code>exclude</code>四个命令</p><pre><code class="go.mod">module hellogo 1.16replace example.com/greetings =&gt; ../greetingsrequire example.com/greetings v1.1.0</code></pre><p> <em>一个典型的go.mod示例</em></p><h3 id="go-sum"><a href="#go-sum" class="headerlink" title="go.sum"></a>go.sum</h3><p>是版本控制相关文件，包含了依赖的module的版本及其Hash</p><h3 id="go"><a href="#go" class="headerlink" title="*.go"></a>*.go</h3><p>Go的源文件</p><pre><code class="golang">package helloimport &quot;testing&quot;func TestHello(t *testing.T) &#123;    want := &quot;Hello, world.&quot;    if got := Hello(); got != want &#123;        t.Errorf(&quot;Hello() = %q, want %q&quot;, got, want)    &#125;&#125;</code></pre><p><em>一个典型的Go程序代码</em></p><h2 id="创建Go-Module的典型过程（一点点shell命令）"><a href="#创建Go-Module的典型过程（一点点shell命令）" class="headerlink" title="创建Go Module的典型过程（一点点shell命令）"></a>创建Go Module的典型过程（一点点shell命令）</h2><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><pre><code class="shell">mkdir hellocd hello</code></pre><h3 id="初始化Go-Module"><a href="#初始化Go-Module" class="headerlink" title="初始化Go Module"></a>初始化Go Module</h3><pre><code class="shell">go mod init example.com/hello</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="shell">go testgo test -v # More Detail</code></pre><h3 id="显示全部依赖的包"><a href="#显示全部依赖的包" class="headerlink" title="显示全部依赖的包"></a>显示全部依赖的包</h3><pre><code class="shell">go list -m all</code></pre><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><pre><code>go get example.com/example</code></pre><h3 id="清理依赖"><a href="#清理依赖" class="headerlink" title="清理依赖"></a>清理依赖</h3><pre><code>go mod tidy</code></pre><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>支持 C 风格的块注释 /* */ 和 C++ 风格的行注释 //</p><p>btw,顶级声明前面的注释都将作为该声明的<strong>文档注释</strong></p><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><pre><code class="go">if condition &#123;    /* Code Here */    return result&#125;</code></pre><p><em>最简单的if结构</em></p><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><pre><code class="go">// 类似 C 语言中的 for 用法for init; condition; post &#123; &#125;// 类似 C 语言中的 while 用法for condition &#123; &#125;// 类似 C 语言中的 for(;;) 用法for &#123; &#125;</code></pre><p><em>三种常用的方式</em></p><pre><code class="go">for key, value := range oldMap &#123;    newMap[key] = value&#125;</code></pre><p><em>很方便的切片</em></p><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><pre><code class="go">func unhex(c byte) byte &#123;    switch &#123;    case &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;:        return c - &#39;0&#39;    case &#39;a&#39; &lt;= c &amp;&amp; c &lt;= &#39;f&#39;:        return c - &#39;a&#39; + 10    case &#39;A&#39; &lt;= c &amp;&amp; c &lt;= &#39;F&#39;:        return c - &#39;A&#39; + 10    &#125;    return 0&#125;</code></pre><p><em>大概是源码里的</em></p><p>switch不会自动向下追溯，所以要使用逗号分隔相同处理的条件，例如：</p><pre><code class="go">func shouldEscape(c byte) bool &#123;    switch c &#123;    case &#39; &#39;, &#39;?&#39;, &#39;&amp;&#39;, &#39;=&#39;, &#39;#&#39;, &#39;+&#39;, &#39;%&#39;:        return true    &#125;    return false&#125;</code></pre><h3 id="结构体、方法与接口"><a href="#结构体、方法与接口" class="headerlink" title="结构体、方法与接口"></a>结构体、方法与接口</h3><h4 id="结构体与方法"><a href="#结构体与方法" class="headerlink" title="结构体与方法"></a>结构体与方法</h4><pre><code class="go">type Student struct &#123;    name string    age  int&#125;func (stu *Student) hello(person string) string &#123;    return fmt.Sprintf(&quot;hello %s, I am %s&quot;, person, stu.name)&#125;func main() &#123;    stu := &amp;Student&#123;        name: &quot;Tom&quot;,    &#125;    msg := stu.hello(&quot;Jack&quot;)    fmt.Println(msg) // hello Jack, I am Tom&#125;</code></pre><h2 id="其他零碎内容"><a href="#其他零碎内容" class="headerlink" title="其他零碎内容"></a>其他零碎内容</h2><h3 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="go">package greetingsimport (    &quot;testing&quot;    &quot;regexp&quot;)// TestHelloName calls greetings.Hello with a name, checking // for a valid return value.func TestHelloName(t *testing.T) &#123;    name := &quot;Gladys&quot;    want := regexp.MustCompile(`\b`+name+`\b`)    msg, err := Hello(&quot;Gladys&quot;)    if !want.MatchString(msg) || err != nil &#123;        t.Fatalf(`Hello(&quot;Gladys&quot;) = %q, %v, want match for %#q, nil`, msg, err, want)    &#125;&#125;// TestHelloEmpty calls greetings.Hello with an empty string, // checking for an error.func TestHelloEmpty(t *testing.T) &#123;    msg, err := Hello(&quot;&quot;)    if msg != &quot;&quot; || err == nil &#123;        t.Fatalf(`Hello(&quot;&quot;) = %q, %v, want &quot;&quot;, error`, msg, err)    &#125;&#125;</code></pre><p><em>一个单元测试的样例</em>      <em>测试文件一定要包含<strong>test</strong>字样</em></p><h4 id="testing-T与testing-M"><a href="#testing-T与testing-M" class="headerlink" title="testing.T与testing.M"></a>testing.T与testing.M</h4><p>testing.T 是普通测试包<br>testing.M函数可以在测试函数执行之前做一些其他操作</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><pre><code class="shell">- cmd    //函数主程序- internal    //私有库- pkg    //公开库- vendor    //依赖- web    //静态Web资源- configs    //配置- init    //系统初始化- scripts    //安装、构建、部署等脚本- build    //打包和持续集成- deployments    IaaS, Paas, 系统, 容器编排的部署配置和模板- test    //额外的外部测试软件和测试数据- docs    //用户及设计文档- examples    //应用或者库的示例文件- tools    //项目的支持工具- third_party    //外部辅助工具, forked 代码, 以及其他第三方工具 - githooks    - assets    //资源文件- website    //站点配置数据</code></pre><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><pre><code class="go">package greetingsimport (    &quot;errors&quot;    &quot;fmt&quot;)// Hello returns a greeting for the named person.func Hello(name string) (string, error) &#123;    // If no name was given, return an error with a message.    if name == &quot;&quot; &#123;        return &quot;&quot;, errors.New(&quot;empty name&quot;)    &#125;    // If a name was received, return a value that embeds the name     // in a greeting message.    message := fmt.Sprintf(&quot;Hi, %v. Welcome!&quot;, name)    return message, nil&#125;</code></pre><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>在函数或方法前添加 <code>go</code> 关键字能够在新的 Go 协程中调用它。当调用完成后， 该 Go 协程也会安静地退出。（效果有点像 Unix Shell 中的 <code>&amp;</code> 符号，它能让命令在后台运行。）</p><pre><code class="go">go list.Sort()  // 同时运行 list.Sort ; 不需要等待</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learnku.com/docs/effective-go/2020">https://learnku.com/docs/effective-go/2020</a></p><p><a href="https://golang.org/doc/tutorial">https://golang.org/doc/tutorial</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://blog.fishsmemory.ml/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://blog.fishsmemory.ml/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>软件工程 - 概述</title>
    <link href="https://blog.fishsmemory.ml/2020/10/12/Software-Engineering/Overview/"/>
    <id>https://blog.fishsmemory.ml/2020/10/12/Software-Engineering/Overview/</id>
    <published>2020-10-12T04:41:39.000Z</published>
    <updated>2021-05-11T15:27:38.925Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="软件的概念和特点"><a href="#软件的概念和特点" class="headerlink" title="软件的概念和特点"></a>软件的概念和特点</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>软件 = 程序 + 文档 + 数据</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>软件是开发的</li><li>软件是简单的拷贝</li><li>软件测试非常困难</li><li>软件需要维护，维护易产生新的问题</li><li>软件开发时间和工作量难以估计</li><li>软件开发时间进度几乎没有客观衡量标准</li><li>软件不会磨损，但是会退化和废弃</li></ol><h2 id="软件危机的概念和成因"><a href="#软件危机的概念和成因" class="headerlink" title="软件危机的概念和成因"></a>软件危机的概念和成因</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>在计算机软件开发和维护中碰到的一系列严重问题。</p><ol><li>项目超出预算</li><li>项目超过计划完成时间</li><li>软件运行效率很低</li><li>软件质量差</li><li>软件通常不符合要求</li><li>项目难以管理并且代码难以维护</li><li>软件不能交付</li></ol><h3 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h3><h4 id="软件自身特点"><a href="#软件自身特点" class="headerlink" title="软件自身特点"></a>软件自身特点</h4><ol><li>软件是逻辑部件，缺乏可预见性</li><li>软件维护困难</li><li>软件越来越庞大复杂，需要分工协作</li></ol><h4 id="软件开发和维护方法不正确"><a href="#软件开发和维护方法不正确" class="headerlink" title="软件开发和维护方法不正确"></a>软件开发和维护方法不正确</h4><ol><li>需求分析不充分或者存在错误</li><li>开发过程不规范</li><li>不注重文档工作，软件难以维护</li><li>缺少软件评测手段</li></ol><h2 id="软件工程定义"><a href="#软件工程定义" class="headerlink" title="软件工程定义"></a>软件工程定义</h2><ol><li>应用系统的、规范的、可度量的方法来开发，运行和维护软件，即把工程应用到软件。</li><li>对 1 各种方法的研究</li></ol><h2 id="软件工程三要素"><a href="#软件工程三要素" class="headerlink" title="软件工程三要素"></a>软件工程三要素</h2><ol><li>方法</li><li>工具</li><li>过程</li></ol><h2 id="软件工程发展过程"><a href="#软件工程发展过程" class="headerlink" title="软件工程发展过程"></a>软件工程发展过程</h2><p>传统软件工程（late 60s - 70s）： 将软件工程纳入工程化轨道 <br>对象工程（80s - 90s）：面向对象的分析与设计 <br>过程工程（mid 80s）：提高软件生产率，保证软件质量 <br>构建工程（90s - ）：复用构件</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="软件工程的目标"><a href="#软件工程的目标" class="headerlink" title="软件工程的目标"></a>软件工程的目标</h3><p>在给定的时间和预算内，按照用户的需求，开发易修改、高效、可靠、可维护、适应力强、可移动、可重用的软件。 <br><del>钱少，要求多</del></p><h3 id="软件分类"><a href="#软件分类" class="headerlink" title="软件分类"></a>软件分类</h3><ol><li>系统软件</li><li>应用软件</li><li>工程/科学软件</li><li>嵌入式软件</li><li>Web应用软件</li><li>产品线软件</li><li>人工智能</li></ol><h3 id="Wasserman-规范"><a href="#Wasserman-规范" class="headerlink" title="Wasserman 规范"></a>Wasserman 规范</h3><ol><li>抽象 Abstration</li><li>分析和设计方法以及表示方法 Analysis and design methods and notations</li><li>用户界面原型化 User interface prototyping</li><li>软件体系结构 Software architecture</li><li>软件过程 Software process</li><li>复用 Reuse</li><li>测度 Measurement</li><li>计算机辅助软件工程 CASE (Computer Aided Software Engineering)</li></ol><h3 id="软件工程七原则"><a href="#软件工程七原则" class="headerlink" title="软件工程七原则"></a>软件工程七原则</h3><ol><li>使用阶段性生命周期计划的管理</li><li>阶段性审查</li><li>保证严格的产品控制</li><li>使用现代编程工具 <del>Fuck Dev C++</del></li><li>保持清晰的责任分配，结果审查清楚 <del>对摸鱼神器？</del></li><li>开发小组人员少而精</li><li>不断改进软件工程实践</li></ol><h3 id="憨批大纲，不考了不更了"><a href="#憨批大纲，不考了不更了" class="headerlink" title="憨批大纲，不考了不更了"></a><del>憨批大纲，不考了不更了</del></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://blog.fishsmemory.ml/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件工程" scheme="https://blog.fishsmemory.ml/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="软件" scheme="https://blog.fishsmemory.ml/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="软件危机" scheme="https://blog.fishsmemory.ml/tags/%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 - 应用层</title>
    <link href="https://blog.fishsmemory.ml/2020/09/19/Computer-Network/Section2-Appllication-Layer/"/>
    <id>https://blog.fishsmemory.ml/2020/09/19/Computer-Network/Section2-Appllication-Layer/</id>
    <published>2020-09-19T02:39:37.000Z</published>
    <updated>2021-05-11T15:27:38.924Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del><em>生气！极其不友好的考纲</em></del></p><h2 id="应用层协议的原理"><a href="#应用层协议的原理" class="headerlink" title="应用层协议的原理"></a>应用层协议的原理</h2><h3 id="网络应用体系结构"><a href="#网络应用体系结构" class="headerlink" title="网络应用体系结构"></a>网络应用体系结构</h3><p>规定如何在各种端系统上组织应用程序，由研发者设计,规定了如何在各种端系统上组织该应用程序。 <br>e.g.</p><ol><li>CS体系结构(Client-Server architecture) </li><li>P2P体系结构(P2P architecture)</li></ol><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程通信实际上是进程(Process)而不是程序，多个进程运行于相同的端系统上时，它们利用进程间通信机制相互通信；进程运行于不同的端系统上时，通过跨越计算机网络交换报文(Message)而互相通信。 <br>进程与计算机网络之间的接口是套接字(Socket)，其中一部分套接字建立了网络应用程序的可编程接口，被称之为应用程序与网络之间的应用程序编程接口(API, Application Programming Interface)。 <br><del>此处值得一提的是</del>进程寻址需要IP与端口号。<del>地址与门牌号</del></p><h3 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h3><p><em>以下为分类</em></p><ol><li>可靠数据传输</li><li>吞吐量</li><li>定时 <del>其实是延迟</del></li><li>安全性</li></ol><h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><ol><li>TCP</li><li>UDP</li></ol><table><thead><tr><th align="center">应用</th><th align="center">应用层协议</th><th align="center">支持的运输协议</th></tr></thead><tbody><tr><td align="center">电子邮件</td><td align="center">SMTP</td><td align="center">TCP</td></tr><tr><td align="center">远程终端访问</td><td align="center">Telnet</td><td align="center">TCP</td></tr><tr><td align="center">Web</td><td align="center">HTTP</td><td align="center">TCP</td></tr><tr><td align="center">文件传输</td><td align="center">FTP</td><td align="center">TCP</td></tr><tr><td align="center">流式多媒体</td><td align="center">HTTP</td><td align="center">TCP</td></tr><tr><td align="center">因特网电话</td><td align="center">SIP、RTP</td><td align="center">TCP/UDP</td></tr></tbody></table><h2 id="应用层协议的实现过程"><a href="#应用层协议的实现过程" class="headerlink" title="应用层协议的实现过程"></a>应用层协议的实现过程</h2><p>应用层协议定义了运行在不同端系统上的应用程序如何进行报文传递，特别定义了一下几部分：</p><ol><li>交换的报文类型</li><li>各种报文类型的语法</li><li>字段的语义</li><li>确定一个进程何时以及如何发送报文，对报文进行响应的规则</li></ol><h2 id="Web-应用和-HTTP-协议"><a href="#Web-应用和-HTTP-协议" class="headerlink" title="Web 应用和 HTTP 协议"></a>Web 应用和 HTTP 协议</h2><p><del>终于到我会一点点的地方了</del> <br>Web的应用层协议核心就是HTTP(HyperText Transfer Protocol)协议，HTTP协议是一个无状态协议。</p><h4 id="持续连接与非持续连接"><a href="#持续连接与非持续连接" class="headerlink" title="持续连接与非持续连接"></a>持续连接与非持续连接</h4><p>每个请求/响应都是由单独的一个TCP连接发送的，是为非持续性连接，反之则是持续连接。 <br>非持续连接存在以下缺点：</p><ol><li>必须为每个请求的对象建立和维护一个全新的连接。</li><li>每个对象经受两倍RTT(Round-Trip Time)的交付延迟，即一个RTT用于创建TCP，一个RTT用于请求和接收一个对象。<h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><del>请打开F12</del> <br><del>Chrome似乎看不到raw的，打开fiddler</del> <br><del>众所周知，百度是用来测试网络连通性的</del> \</li></ol><p><em>以下报文删去了一部分内容</em> <br><em>请注意HTTPS类型的traffic请在fiddler中信任根证书</em> <br>请求报文样例</p><pre><code>GET https://www.baidu.com/ HTTP/1.1Host: www.baidu.comConnection: keep-aliveAccept: text/plain, */*; q=0.01User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36X-Requested-With: XMLHttpRequestSec-Fetch-Site: same-originSec-Fetch-Mode: corsSec-Fetch-Dest: emptyReferer: https://www.baidu.com/Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7</code></pre><p>响应报文样例</p><pre><code>HTTP/1.1 200 OKCache-Control: privateConnection: keep-aliveContent-Encoding: gzipContent-Type: text/html;charset=utf-8Date: Mon, 12 Oct 2020 08:05:44 GMTExpires: Mon, 12 Oct 2020 08:05:44 GMTServer: BWS/1.0Vary: Accept-EncodingContent-Length: 49</code></pre><p>没什么好讲的（确信<br>来记一些状态码吧！</p><ul><li>200 OK</li><li>301 Moved Permanently</li><li>400 Bad Request</li><li>404 Not Found</li><li>505 HTTP Version Not Supported</li><li>500 Internal Server Error</li></ul><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>前文已经提到了，HTTP是一种无状态协议，这意味着将无法识别用户，为了解决这个问题，HTTP使用了Cookie对用户进行识别追踪。<br><img src="https://cdn.jsdelivr.net/gh/SkadiWo/BlogResources/img/Using%20Cookie.jpg" alt="Using Cookie" loading="lazy"></p><h4 id="Web缓存器"><a href="#Web缓存器" class="headerlink" title="Web缓存器"></a>Web缓存器</h4><p>Web Cache A.K.A Proxy Server <br>How does it work: </p><ol><li>浏览器创建一个到Web缓存器的TCP连接，并为向其中所请求的对象发送一个HTTP请求</li><li>Web缓存器检查其本地是否存有该对象，若有则响应报文并返回该对象</li><li>若不存在该对象，则在与服务器(该对象本来的来源处)的TCP连接上，发送对此对象的请求。</li><li>当Web缓存器接收到此对象时，先于本地存储一份副本，随后将其发至客户端。</li></ol><p>Why: 代替原始服务器满足HTTP请求 <del>并且减少接入公共因特网带宽成本</del><br>e.g. CDN(Content Distribution Network)</p><h4 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h4><p>Client请求：If-modified-since: &lt;date&gt; <br>未修改则：HTTP/1.0 304 Not Modified <br>修改则：&lt;data&gt;</p><h2 id="FTP-协议的实现机制"><a href="#FTP-协议的实现机制" class="headerlink" title="FTP 协议的实现机制"></a>FTP 协议的实现机制</h2><p><em>书上没有这一节</em> <br><em>参阅以前的课件作如下描述</em><br>FTP用于传输文件到远程主机/从远程主机下载文件，存在以下两种模式<br>client/server模式</p><ul><li>client: 发起传输的一方</li><li>server: 远程主机</li></ul><p>对于ftp服务器，其默认端口号为21(控制端口)。</p><h3 id="FTP传输过程"><a href="#FTP传输过程" class="headerlink" title="FTP传输过程"></a>FTP传输过程</h3><ol><li>FTP客户首先发起建立1个与FTP服务器端口21之间的TCP控制连接, TCP为传输层协议</li><li>客户在控制连接上获得身份认证，发送各种控制命令.</li><li>服务器收到1个文件传输命令时, 服务器在端口20(数据传输端口)创建1个与客户端口的TCP数据连接（Port）</li><li>1个文件传输后,服务器结束这个TCP数据连接.</li></ol><h3 id="其他？（我也不知道怎么描述"><a href="#其他？（我也不知道怎么描述" class="headerlink" title="其他？（我也不知道怎么描述"></a>其他？（我也不知道怎么描述</h3><ol><li>服务器创建第2个TCP与客户的数据连接来传输下一个文件.</li><li>控制连接: 带外发送控制信息</li><li>FTP 服务器维护用户状态信息: 当前目录, 先前身份认证</li></ol><h3 id="PORT模式"><a href="#PORT模式" class="headerlink" title="PORT模式"></a>PORT模式</h3><p>PORT模式下的FTP服务： 缺省情况下PORT模式的数据端口是20， 控制端口是21（控制端口可以设定， 本文假定使用21）。 当进行连接时,客户端使用一个随机的端口N（N大于1024)连接服务器的控制端口21， 然后客户端开始监听端口N+1，并向服务器发送命令 PORT N+1，服务器用自己的数据端口20连回客户的N+1端口。 由于PORT模式仅仅是发送端口给服务器，由服务器连回客户端，如果客户端有防火墙，这样的连接会被认为是外部主机试图连接内部的主机， 通常情况下是不允许的。 </p><h3 id="PASV模式"><a href="#PASV模式" class="headerlink" title="PASV模式"></a>PASV模式</h3><p>PASV模式下的FTP服务： 当进行连接时,客户端使用一个随机的端口N（N大于1024) 连接服务器的控制端口21， 并向服务器发送命令 PASV，服务器使用一个随机的数据端口M(M&gt;1024)并发回客户端, 客户端用数据端口N+1连接服务器的端口M。 由于客户端发起数据连接， 这样就解决了防火墙带来的问题。 </p><h2 id="DNS-的功能和实现方法"><a href="#DNS-的功能和实现方法" class="headerlink" title="DNS 的功能和实现方法"></a>DNS 的功能和实现方法</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol><li>主机名到IP地址转换 (Main)</li><li>主机别名</li><li>邮件服务器别名(MX记录)</li><li>负载均衡</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ol><li>单点故障</li><li>通信容量</li><li>远距离的集中式数据库</li><li>维护</li></ol><h4 id="解决方案-——-分布式、层次数据库"><a href="#解决方案-——-分布式、层次数据库" class="headerlink" title="解决方案 —— 分布式、层次数据库"></a>解决方案 —— 分布式、层次数据库</h4><h5 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h5><p><img src="https://cdn.jsdelivr.net/gh/SkadiWo/BlogResources/img/DNS%20architecture.jpg" alt="DNS Architecture" loading="lazy"><br>由根DNS服务器提供TLD(Top-Level Domain)服务器的IP地址，每个TLD服务器又提供了权威DNS服务器的IP地址，最后由权威DNS服务器，将这些主机名映射为IP地址。</p><h5 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h5><p>其实是本地DNS服务器，可参见Web Cache做类比。</p><h5 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h5><p>DNS记录由四元组构成，如下</p><pre><code>（Name, Value, Type, TTL)</code></pre><p>其中TTL代表该记录的生存时间，Type决定了Name和Value。 <br>以下是几种常见的Type与其对应的Name和Value：</p><ul><li>(Name, IPv4 Address, A, TTL) e.g. (blog, IPv4 Address, A, TTL)</li><li>(Name, IPv6 Address, AAA, TTL) e.g. (blog, IPv6 Address, AAA, TTL)</li><li>(Name, Domain, NS, TTL) e.g. (Tinysnow, A NS Server, NS, TTL)</li><li>(Name, Domain, CNAME, TTL) e.g. (blog, skadiwo.github.io, CNAME, TTL)</li><li>(Name, Domain, MX, TTL) e.g. (mail, mail.163.com, MX, TTL) <em>禁止指向CNAME</em> </li></ul><p>报文构成 <br><img src="https://cdn.jsdelivr.net/gh/SkadiWo/BlogResources/img/DNS%20Message.png" alt="DNS Message" loading="lazy"></p><h2 id="电子邮件系统的构成、传输机制和协议"><a href="#电子邮件系统的构成、传输机制和协议" class="headerlink" title="电子邮件系统的构成、传输机制和协议"></a>电子邮件系统的构成、传输机制和协议</h2><h3 id="构成与传输机制"><a href="#构成与传输机制" class="headerlink" title="构成与传输机制"></a>构成与传输机制</h3><p><img src="https://cdn.jsdelivr.net/gh/SkadiWo/BlogResources/img/Email%20Achitecture.jpg" alt="Email Architecture" loading="lazy"><br>于上图可知，因特网电子邮件系统有三个组成部分：用户代理(User Agent)、邮件服务器(Mail Server)、简单邮件传输协议(Simple Mail Transfer Protocol,SMTP)<br>一个典型的邮件发送过程是：从发送方的用户代理开始．传输到发送方的邮件服务器、再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中。</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p><del><em>写不动了自己看吧</em></del></p><ul><li>SMTP -&gt; <a href="https://www.youtube.com/watch?v=PJo5yOtu7o8">https://www.youtube.com/watch?v=PJo5yOtu7o8</a></li><li>POP3 &amp; IMAP -&gt; <a href="https://www.youtube.com/watch?v=SBaARws0hy4">https://www.youtube.com/watch?v=SBaARws0hy4</a></li></ul><h2 id="TCP-和-UDP-套接字编程"><a href="#TCP-和-UDP-套接字编程" class="headerlink" title="TCP 和 UDP 套接字编程"></a>TCP 和 UDP 套接字编程</h2><h3 id="UDP套接字"><a href="#UDP套接字" class="headerlink" title="UDP套接字"></a>UDP套接字</h3><p><img src="https://cdn.jsdelivr.net/gh/SkadiWo/BlogResources/img/UDP%20CS%20Application.jpg" alt="UDP" loading="lazy"></p><h4 id="UDP-Client"><a href="#UDP-Client" class="headerlink" title="UDP Client"></a>UDP Client</h4><pre><code class="python3">from socket import *  # 导包serverName = &#39;localhost&#39;  # 设置服务器主机名serverPort = 12000  # 设置服务器端口号# AF_INET代表了IPv4，SOCK_DGRAM代表了这是个UDP的SocketclientSocket = socket(AF_INET, SOCK_DGRAM)message = input(&#39;Input lowercase sentence&#39;)  # 输入要哔哔的话clientSocket.sendto(message.encode(), (serverName,                                       serverPort))  # 咱就给您送出去！（顺便编个码）modifiedMessage, serverAddress = clientSocket.recvfrom(2048)  # 好咧，别人给您的回信来啦！print(modifiedMessage.decode())  # 看看别人咋哔哔的（顺便解个码）clientSocket.close()    # 再见了您咧！</code></pre><h4 id="UDP-Server"><a href="#UDP-Server" class="headerlink" title="UDP Server"></a>UDP Server</h4><pre><code class="python3">from socket import *  # 导包serverName = &#39;localhost&#39;  # 设置服务器主机名serverPort = 12000  # 设置服务器端口号# AF_INET代表了IPv4，SOCK_DGRAM代表了这是个UDP的SocketserverSocket = socket(AF_INET, SOCK_DGRAM)serverSocket.bind((&#39;&#39;, serverPort))  # 绑定IP和端口喔！print(&quot;The Server is ready to recive!&quot;)  # 准备好啦！while True:    message, clientAddress = clientSocket.recvfrom(2048)  # 好呀，看看谁来信了！    modifiedMessage = message.decode().upper()  # 解个码变大写！    serverSocket.sendto(modifiedMessage.encode(),                        clientAddress)  # 咱就给您送回去！（顺便编个码）# 惨，Server不能关（?</code></pre><h2 id="P2P-文件共享原理"><a href="#P2P-文件共享原理" class="headerlink" title="P2P 文件共享原理"></a>P2P 文件共享原理</h2><p><img src="https://cdn.jsdelivr.net/gh/SkadiWo/BlogResources/img/CS%20VS%20P2P.PNG" alt="CS VS P2P" loading="lazy"></p><h3 id="P2P-集中式目录"><a href="#P2P-集中式目录" class="headerlink" title="P2P 集中式目录"></a>P2P 集中式目录</h3><p>上图中，若在P2P网络中加入一个作为目录（索引）的服务器，为对等方提供检索服务，即为P2P集中式目录(结构)。</p><ul><li>单点故障</li><li>性能瓶颈</li><li>侵犯版权</li></ul><h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><p>BitTorrent 是一种用于文件分发的流行P2P协议。参与一个特定文件分发的所有对等方的集合被称之为一个torrent；在一个torrent中，对等方彼此下载等长度的chunk，典型的chunk长度(size)为256KB。</p><h3 id="DHT-Distributed-Hash-Table"><a href="#DHT-Distributed-Hash-Table" class="headerlink" title="DHT(Distributed Hash Table)"></a>DHT(Distributed Hash Table)</h3><p><img src="https://cdn.jsdelivr.net/gh/SkadiWo/BlogResources/img/DHT.PNG" alt="DHT" loading="lazy"><br>使用键值对(Key-Value)进行存储，每个对等方皆能查询(get)与插入(put)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://blog.fishsmemory.ml/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="应用层" scheme="https://blog.fishsmemory.ml/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
      <category term="HTTP" scheme="https://blog.fishsmemory.ml/tags/HTTP/"/>
    
      <category term="Web Cache" scheme="https://blog.fishsmemory.ml/tags/Web-Cache/"/>
    
      <category term="Cookie" scheme="https://blog.fishsmemory.ml/tags/Cookie/"/>
    
      <category term="DNS" scheme="https://blog.fishsmemory.ml/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 - 计算机与因特网</title>
    <link href="https://blog.fishsmemory.ml/2020/08/01/Computer-Network/Section1-Computer-And-Internet/"/>
    <id>https://blog.fishsmemory.ml/2020/08/01/Computer-Network/Section1-Computer-And-Internet/</id>
    <published>2020-08-01T12:10:41.000Z</published>
    <updated>2021-05-11T15:27:38.924Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>类比于人类活动，协议是一种预先规定好的行为方式。<br>在网络中，协议用于控制因特网信息的接受和发送。<br><strong>网络协议定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和或接收一条报文或其他事件所采取的动作。</strong></p><h2 id="无连接和面向连接服务"><a href="#无连接和面向连接服务" class="headerlink" title="无连接和面向连接服务"></a>无连接和面向连接服务</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="无连接服务"><a href="#无连接服务" class="headerlink" title="无连接服务"></a>无连接服务</h4><p>无连接协议中的分组被称为数据报(datagram)，每个分组都是独立寻址，并由应用程序发送的。<br>从协议的角度来看，每个数据报都是一个独立的实体，与在两个相同的对等实体之间传送的任何其他数据报都没有关系，这就意味着协议很可能是不可靠的。也就是说，网络会尽最大努力传送每一个数据报，但并不保证数据报不丢失、不延迟或者不错序传输。<br><strong>无连接服务仅有数据传输这个阶段</strong><br>显而易见的，无连接服务有以下几个特点：</p><ol><li>不提供数据的可靠传输</li><li>不提供流量控制(Traffic Control)</li><li>不提供拥塞控制</li></ol><h4 id="面向连接服务"><a href="#面向连接服务" class="headerlink" title="面向连接服务"></a>面向连接服务</h4><p>面向连接的协议则维护了分组之间的状态，使用这种协议的应用程序通常都会进行长期的对话。记住这些状态，协议就可以提供可靠的传输。<br>比如，发送端可以记住哪些数据已经发送出去了但还未被确认，以及数据是什么时候发送的。如果在某段时间间隔内没有收到确认，发送端可以重传数据。接收端可以记住已经收到了哪些数据，并将重复的数据丢弃。如果分组不是按序到达的，接收端可以将其保存下来，直到逻辑上先于它的分组到达为止。<br><strong>面向连接服务也要经过三个阶段：数据传数前，先建立连接，连接建立后再传输数据，数据传送完后，释放连接。</strong><br>对比于无连接，面向连接显然有:</p><ol><li>可靠的、按序提交 数据包传输服务</li><li>流量控制</li><li>拥塞控制</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>其一：面向连接分为三个阶段，第一是建立连接，在此阶段，发出一个建立连接的请求。只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，必须释放连接。而面向无连接没有这么多阶段，它直接进行数据传输。 <br>其二：面向连接的通信具有数据的保序性， 而面向无连接的通信不能保证接收数据的顺序与发送数据的顺序一致。 <br>值得一提的是，无连接一般采用UDP,面向连接一般采用TCP。<del>废话</del></p><h2 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h2><p><img src="https://cdn.jsdelivr.net/gh/SkadiWo/BlogResources/img/Three%20Method%20to%20Switching.png" alt="三种数据交换" loading="lazy"></p><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>报文交换(Message Switching)的单位是报文，报文携带有目标地址、源地址等信息。报文交换在交换结点采用的是存储转发(store-and-forward transmission)的传输方式。 <br>报文交换有两种复用方式：频分复用与时分复用。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>无需建立连接： 报文交换不需要为通信双方预先建立一条专用的通信线路，不存在建立连接时延， 用户可以随时发送报文。</li><li>动态分配线路： 当发送方把报文交给交换设备时，交换设备先存储整个报文，然后选择一条合适的空闲线路，将报文发送出去。</li><li>提高线路可靠性： 如果某条传输路径发生故障， 可重新选择另一条路径传输数据， 所以提高了传输的可靠性。</li><li>提高线路利用率： 通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通道，因而大大提高了通信线路的利用率。</li><li>提供多目标服务： 一个报文可以同时发送往多个目的地址，这在电路交换中是很难实现的．</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>由千数据进入交换结点后要经历存储、转发这一过程，从而引起转发时延(包括接收报文、检验正确性、排队、发送时间等)</li><li>报文交换对报文的大小没有限制，这就要求网络结点需要有较大的缓存空间。</li></ol><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>分组交换(Packet Switching)也采用了存储转发方式，分组交换限制了每次传送的数据块大小的上限，把大的数据块划分为合理的小数据块，再加上一些必要的控制信息(如源地址、目的地址和编号信息等) ， 构成分组( Packet ) 。网络结点根据控制信息把分组送到下一结点， 下一结点接收到分组后，暂时保存下来并排队等待传输，然后根据分组控制信息选择它的下一个结点，直到到达目的结点。 <br>虚电路网络与数据报网络属于此类。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>无建立时延。不需要为通信双方预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送分组。</li><li>线路利用率高。通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通路， 因而大大提高了通信线路的利用率。</li><li>简化了存储管理(相对千报文交换)。因为分组的长度固定， 相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理， 相对比较容易。</li><li>加速传输： 分组是逐个传输， 可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线方式减少了报文的传输时间。此外， 传输一个分组所需的缓冲区比传输一次报文所需的缓冲区小得多，这样因缓冲区不足而等待发送的几率及时间也必然少得多．</li><li>减少了出错几率和重发数据呈： 因为分组较短，其出错几率必然减少， 所以每次重发的数据证也就大大减小，这样不仅提高了可靠性，也减少了传输时延。</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>l. 存在传输时延。尽管分组交换比报文交换的传输时延少，但相对于电路交换仍存在存储一转发时延， 而且其结点交换机必须具有更强的处理能力。<br>2. 需要传输额外的信息批。每个小数据块都要加上源、目的地址和分组编号等信息，从而构成分组，使传送的信息杂大约增大5%~1 0%， 一定程度上降低了通信效率， 增加了处理的时第间，使控制复杂，时延增加。<br>3. 当分组交换采用数据报服务时，可能出现失序、丢失或重复分组， 分组到达目的结点时，要对分组按编号进行排序等工作，增加了麻烦。若采用虚电路服务， 虽无失序问题，但有呼叫建物立、数据传输和虚电路释放三个过程。</p><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>对于电路交换(Circuit Switching)，在进行数据传输前，两个结点之间必须先建立一条专用(双方独占)的物理通信路径(由通信双方之间的交换设备和链路逐段连接而成)，该路径能经过许多中间结点。该线路在整个数据传输期间一直被独占，直到通信结束后才被释放。因此， 电路交换技术分为三个阶段： 连接建立、数据传输和连接释放。 <br>从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。电路交换的关键点是： 在数据传输的过程中，用户始终占用端到端的固定传输带宽。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol><li>通信时延小。由千通信线路为通信双方用户专用，数据直达，所以传输数据的时延非常小。当传输的数据拉较大时，这一优点非常明显。</li><li>有序传输。双方通信时按发送顺序传送数据， 不存在失序问题。</li><li>没有冲突。不同的通信双方拥有不同的信道，不会出现争用物理信道的问题。</li><li>适用范围广。电路交换既适用于传输模拟信号， 又适用千传输数字信号。</li><li>实时性强。通信双方之间的物理通路一旦建立，双方可以随时通信。</li><li>控制简单。电路交换的交换设备(交换机等)及控制均较简单。</li></ol><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol><li>建立连接时间长。电路交换的平均连接建立时间对计算机通信来说太长。</li><li>线路独占，使用效率低。电路交换连接建立后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用率低。</li><li>灵活性差。只要在通信双方建立的通路中的任何一点出了故院，就必须亟新拨号建立新的连接， 这对十分紧急和重要的通信是很不利的。</li><li>难以规格化。电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。</li></ol><h3 id="分组交换与电路交换的对比"><a href="#分组交换与电路交换的对比" class="headerlink" title="分组交换与电路交换的对比"></a>分组交换与电路交换的对比</h3><p>分组交换的性能由于电路交换</p><table><thead><tr><th align="center">电路交换</th><th align="center">分组交换</th></tr></thead><tbody><tr><td align="center">电路交换不考虑需求，而预先分配传输链路的使用</td><td align="center">分组交换按需分配链路使用</td></tr></tbody></table><h2 id="网络时延"><a href="#网络时延" class="headerlink" title="网络时延"></a>网络时延</h2><h3 id="分组转发时延"><a href="#分组转发时延" class="headerlink" title="分组转发时延"></a>分组转发时延</h3><h4 id="单节点时延"><a href="#单节点时延" class="headerlink" title="单节点时延"></a>单节点时延</h4><ol><li>节点处理时延 Nodal Processing delay</li><li>排队时延 Queueing delay</li><li>传输时延 Transmission delay</li><li>传播时延 Propagation delay</li></ol><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><h4 id="单节点时延-1"><a href="#单节点时延-1" class="headerlink" title="单节点时延"></a>单节点时延</h4><p>$$d_{nodal} = d_{proc} + d_{queue} + d_{prop}$$</p><h4 id="端时延"><a href="#端时延" class="headerlink" title="端时延"></a>端时延</h4><p>$$d_{end-end} = N(d_{proc} + d_{trans} + d_{prop})$$<br>$$d_{trans} = L/R$$<br>上式中，L为分组长度，R为传输速度，N-1为链路中路由器个数。</p><h4 id="排队时延-流量强度"><a href="#排队时延-流量强度" class="headerlink" title="排队时延 流量强度"></a><del>排队时延</del> 流量强度</h4><p>$$La/R$$<br>上式中，a的单位是分组/秒，L是单组比特长度，R为传输速度，上式计算流量强度 <br>$La/R$ -&gt; 0: 分组稀疏到达,无队列,平均排队延迟极小接近于0 <br>$La/R$ -&gt; 1: 分组猝发到达,形成队列,队列长度迅速增加,排队延迟大幅增大 <br>$La/R$ &gt; 1: 输出队列平均位到达速率超过送走这些位的极限速率，输出队列持续增长，排队延迟趋于无穷大 <br><img src="https://cdn.jsdelivr.net/gh/SkadiWo/BlogResources/img/traffic%20intensity%20with%20average%20queueing%20delay.jpg" loading="lazy"></p><h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>使复杂系统简化(分而治之)<br>易于维护、系统更新</p><h3 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h3><p>采用分层的方式组织协议及实现协议的网络硬件与软件。 \</p><h4 id="分层的特点"><a href="#分层的特点" class="headerlink" title="分层的特点"></a>分层的特点</h4><p>每层都有对应的一系列协议 <br>每层协议通过软件、硬件或者两者结合实现 <br>每层协议可分布在网络的不同组件之中</p><h4 id="分层的缺点"><a href="#分层的缺点" class="headerlink" title="分层的缺点"></a>分层的缺点</h4><p>有些功能可嫩在不同层重复出现 <del>这个缺点真扯淡</del> <br>某些功能可能需要仅存在其他层的信息 <del>那解耦啊</del></p><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p><img src="https://cdn.jsdelivr.net/gh/SkadiWo/BlogResources/img/Computer%20Network%20Architecture.jpg" loading="lazy"></p><h3 id="各层交互的封装过程"><a href="#各层交互的封装过程" class="headerlink" title="各层交互的封装过程"></a>各层交互的封装过程</h3><p><img src="https://cdn.jsdelivr.net/gh/SkadiWo/BlogResources/img/Encapsulation.jpg" loading="lazy"><br>运输层获得应用层报文(application-layer message)$M$，附上运输层头部信息$H_1$，构成运输层报文段(lransport-layer segment)，$H_1$也许包括了：如允许接收端运输层向上向适当的应用程序交付报文的信息;如差错检测位信息，该信息让接收方能够判断报文中的比特是存在途中已被改变。 <br>随后运输层向网络层提交该报文段，网络层则增加了网络层首部信息$H_2$，构成网络层数据报(network-layer dal唔ram)，$H_2$包含如源和目的端系统地址等。 <br>此数据报随后交付给链路层，链路层也增加了链路层首部信息，构成链路层帧(link-layer frame)。 <br>在此过程中，每一个分组都有两种类型的字段：首部字段和有效载荷字段(payload filed)。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>计算机网络：自顶向下方法(原书第七版) <br>《计算机网络(第7版)》 <br>2019年王道计算机网络考研复习指导 <br><a href="https://blog.csdn.net/tennysonsky/article/details/44455565">https://blog.csdn.net/tennysonsky/article/details/44455565</a> <br><a href="https://www.zhihu.com/question/289026686/answer/1199958592">https://www.zhihu.com/question/289026686/answer/1199958592</a> <br><a href="https://blog.csdn.net/tennysonsky/article/details/44455565">https://blog.csdn.net/tennysonsky/article/details/44455565</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://blog.fishsmemory.ml/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络协议" scheme="https://blog.fishsmemory.ml/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="无连接" scheme="https://blog.fishsmemory.ml/tags/%E6%97%A0%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="面向连接" scheme="https://blog.fishsmemory.ml/tags/%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="电路交换" scheme="https://blog.fishsmemory.ml/tags/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2/"/>
    
      <category term="分组交换" scheme="https://blog.fishsmemory.ml/tags/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2/"/>
    
      <category term="网络延时" scheme="https://blog.fishsmemory.ml/tags/%E7%BD%91%E7%BB%9C%E5%BB%B6%E6%97%B6/"/>
    
      <category term="计算机网络体系结构" scheme="https://blog.fishsmemory.ml/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>不咕咕！-&gt; 咕咕咕</title>
    <link href="https://blog.fishsmemory.ml/2020/07/19/start/"/>
    <id>https://blog.fishsmemory.ml/2020/07/19/start/</id>
    <published>2020-07-19T03:34:02.000Z</published>
    <updated>2021-05-11T15:12:21.070Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前世"><a href="#前世" class="headerlink" title="前世"></a>前世</h2><p>17年至今，笔者已经换了很多个博客程序了，从Wordpress到Typecho，又从Typecho到Hexo。<br>每次都想留下一些什么，然而日常咕咕咕。<br>也许是时候不咕咕了。</p><h2 id="今生"><a href="#今生" class="headerlink" title="今生"></a>今生</h2><p>这个博客将会用来记录我的CS学习/复习内容。<br>包括但不限于一下内容：</p><ul><li><del>计算机网络</del></li><li><del>数据结构与算法</del></li><li><del>操作系统</del></li><li><del>计算机组成原理</del></li><li><del>炼丹</del></li><li><del>软件工程</del><h2 id="2020-09-19"><a href="#2020-09-19" class="headerlink" title="2020.09.19"></a>2020.09.19</h2><del>咕咕咕诈尸</del><h2 id="2020-12-15"><a href="#2020-12-15" class="headerlink" title="2020.12.15"></a>2020.12.15</h2>全咕掉了！不考研了！<h2 id="2020-12-19"><a href="#2020-12-19" class="headerlink" title="2020.12.19"></a>2020.12.19</h2>来学数学了！<h2 id="2020-12-20"><a href="#2020-12-20" class="headerlink" title="2020.12.20"></a>2020.12.20</h2>随缘更新.jpg<h2 id="2021-05-11"><a href="#2021-05-11" class="headerlink" title="2021.05.11"></a>2021.05.11</h2>咕~</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
